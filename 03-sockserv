#!/usr/bin/python3
#

# Global Variables (change these if you must)
_log_level_ = 0
_refresh_rate_ = 60
_server_port_ = 3145
_start_volume_ = 25
_config_sep_ = '|-:;:-|'
_server_address_ = '127.0.0.1'
_music_dir_ = '/home/mp3/music'
_log_file_ = '/home/mp3/mp3.145/mp3145.log'
_persistance_ = '/home/mp3/mp3.145/mp3145.cfg'

#----------------------------------------------------------
#
# DO NOT TOUCH BELOW THIS POINT !!!!!!!!!
#
#----------------------------------------------------------

# Imports
import os 
import random
import pygame
import threading
import socketserver
from time import sleep

# The logger / printer
def dprint(data = ''):
	global _log_file_
	global _log_level_
	if (_log_level_ > 0):
		log_dev = open(_log_file_, 'a')
		print(data, end = '', file = log_dev)
		log_dev.close()
	if (_log_level_ > 1):
		print(data, end = '')
	
# The pygame backend
dprint('Loading music thread...\n')
class musicThread(threading.Thread):
	def __init__(self, music_directory):
		threading.Thread.__init__(self)
		global _start_volume_	
		self.alive = 1
		self.force = -1
		self.shuffle = 1
		self.playing = 0
		self.current = -1
		self.volume = 0.1
		self.previous = -1		
		pygame.mixer.init()
		self.musicdir = music_directory
		self.setVol(2, _start_volume_, 0)
		self.playlist = self.genPlaylist()	
	def writePersist(self):
		global _config_sep_
		data =	str(self.playing) + _config_sep_ + str(self.shuffle) + _config_sep_ + str(self.volume + 0.01) + _config_sep_ + str(self.current) + _config_sep_ + str(self.force)
		global _persistance_
		persist = open(_persistance_, 'w')
		print(data, end = '', file = persist)
		persist.close()	
	def genPlaylist(self):
		genlist = []
		for root, subdirs, thefiles in os.walk(self.musicdir):
			for name in thefiles:
				if (name[-4:].lower() == '.mp3'):
					genlist.append(os.path.join(root, name))
					dprint('Found: ' + os.path.join(root, name) + '\n')
			for name in subdirs:
				dprint(os.path.join(root, name) + '\n')			
		return sorted(genlist)
	def refreshMusic(self):
		oldcur = self.current
		if (oldcur != -1):
			oldcur = self.playlist[self.current]
		self.playlist = self.genPlaylist()
		if (oldcur != -1):
			for x in range(0, len(self.playlist)):
				if (self.playlist[x] == oldcur): 
					self.current = x
					break					
	def getStatus(self):
		retme = ''
		if (self.playing): retme += 'Playing '
		else: retme +='Stopped on '
		if (self.current != -1): retme += self.getCurrent() + ', '
		else: retme += '?: No Song, '
		if (self.shuffle): retme += 'shuffle is on, '
		else: retme += 'shuffle is off, '
		retme += 'volume is ' + str(int(self.volume*100))
		if (self.force != -1): retme += ', queued ' + str(self.force)
		return retme
	def getList(self):
		return self.playlist
	def getVol(self):
		return str(self.volume * 100)
	def setVol(self, upordown = -1, forcevol = 10, persist = 1):
		newvol = self.volume
		if (upordown == 2):
			newvol = (forcevol / 100)
		elif (upordown == 1):
			newvol += 0.1
		elif (upordown == -1):
			newvol -= 0.1
		if (newvol > 1.0):
			newvol = 1.0
		elif (newvol < 0.0):
			newvol = 0.0
		pygame.mixer.music.set_volume(newvol)
		self.volume = pygame.mixer.music.get_volume()
		if (persist): self.writePersist()
		return str(self.volume * 100)
	def setShuffle(self):
		if (self.shuffle == 0):
			self.shuffle = 1
		else:
			self.shuffle = 0
		self.writePersist()
		return self.shuffle
	def setPlay(self):
		if (self.playing == 0):
			self.playing = 1
			while (pygame.mixer.music.get_busy() != 1):
				sleep(0.1)
			self.writePersist()
			return self.current
		else:
			self.playing = 0
		return self.playing
	def setDie(self):
		self.playing = 0
		self.writePersist()
		sleep(1)
		self.alive = 0
	def setForce(self, force):
		self.force = force
		if (force > 0):
			self.writePersist()
			return self.cleanName(self.playlist[self.force])
	def getCurrent(self): 
		return str(self.current) + '/' + str(len(self.playlist)) + ': ' + self.cleanName(self.playlist[self.current])
	def playLast(self):
		if (self.shuffle == 1):
			self.setForce(self.previous)
			return self.playNext()
		else:
			self.setForce(self.current - 1)
			return self.playNext()
	def cleanName(self, name = ''): 
		return name[len(self.musicdir):-4].replace(os.sep, ' ')
	def playNext(self, replay = 0):
		if (replay == 0):
			self.previous = self.current
			if (self.force == -1):
				if (self.shuffle == 1):
					self.current = random.randrange(len(self.playlist))
				else:
					self.current += 1
					if (self.current >= len(self.playlist)):
						self.current = self.current - len(self.playlist)
			else:
				self.current = self.force
				self.force = -1
		
		if (pygame.mixer.music.get_busy()):
			pygame.mixer.music.stop()
		pygame.mixer.music.load(self.playlist[self.current])
		pygame.mixer.music.play()	
		self.writePersist()
		return self.cleanName(self.playlist[self.current])
	def run(self):
		refr = 0
		flag = 0
		initforce = -1
		global _persistance_
		if (os.path.isfile(_persistance_)):
			global _config_sep_
			persist = open(_persistance_, 'r')
			conf = persist.readline()
			persist.close()
			dprint('Persistance;' + conf + '\n')
			values = conf.split(_config_sep_)
			self.playing = int(values[0])
			self.shuffle = int(values[1])
			self.setVol(2, int(float(values[2])*100))
			self.force = int(values[3])
			initforce = int(values[4])
		while (self.alive):
			if ((pygame.mixer.music.get_busy() == 0) and (self.playing == 1)):
				dprint(self.playNext(flag) + '\n')
				if (initforce >= 0):
					self.force = initforce
					initforce = -1
				flag = 0
			elif ((pygame.mixer.music.get_busy() == 1) and (self.playing == 0)):
				pygame.mixer.music.stop()
				flag = 1
			refr += 1
			global _refresh_rate_
			if (refr == ((_refresh_rate_ * 2) +1)):
				self.refreshMusic()
				self.writePersist()
				refr = 0
			sleep(0.5)

dprint('Starting music thread...\n')
music = musicThread(_music_dir_)
music.start()

# The socketserver interface
dprint('Loading TCP server...\n')
class MyTCPHandler(socketserver.BaseRequestHandler):
	def handle(self):
		self.active = 1
		dprint(self.client_address[0] + ' has connected.\n')
		while (self.active):
			global music			
			#self.request.sendall(b'Enter command, h for help: ')
			self.cmd = self.request.recv(1024).strip().decode('utf-8')
			dprint('Command: <' + self.cmd + '> From: [' + self.client_address[0] + ']\n')
			plist = music.getList()
			if (self.cmd == 'h'):				
				dprint('Sending help.\n')
				self.request.sendall(b'Commands:\n')
				self.request.sendall(b'---------\n')
				self.request.sendall(b'p - play/stop\n')
				self.request.sendall(b'n - skip/next\n')
				self.request.sendall(b'b - back/previous\n')
				self.request.sendall(b'r - random on/off\n')			
				self.request.sendall(b's - search songs\n')
				self.request.sendall(b'f - force song\n')
				self.request.sendall(b'l - list all songs\n')
				self.request.sendall(b'u - volume +10\n')
				self.request.sendall(b'd - volume -10\n')
				self.request.sendall(b'v - custom volume\n')
				self.request.sendall(b'x - exit\n')
			elif (self.cmd == 'r'):
				if (music.setShuffle()):
					dprint('Random: On.\n')
					self.request.sendall(b'Random: On\n')
				else:
					dprint('Random: Off.\n')
					self.request.sendall(b'Random: Off\n')
			elif (self.cmd == 'p'):
				if (music.setPlay()):
					dprint('Play.\n')
					self.request.sendall(b'Play\n')
				else:
					dprint('Stop.\n')
					self.request.sendall(b'Stop\n')
			elif (self.cmd == 'n'):
				tmp = music.playNext() + '\n'
				dprint(tmp)
				self.request.sendall(tmp.encode('utf-8'))
			elif (self.cmd == 'c'):
				tmp = music.getStatus() + '\n'
				dprint(tmp)
				self.request.sendall(tmp.encode('utf-8'))
			elif (self.cmd == 'b'):
				tmp = music.playLast() + '\n'
				dprint(tmp)
				self.request.sendall(tmp.encode('utf-8'))
			elif (self.cmd == 'l'):
				dprint('Sending playlist.\n')
				self.request.sendall(b'<table style="font-size: 30px">')
				for x in range(0, len(plist)):
					self.request.sendall(b'<tr><td>' + str(x).encode('utf-8') + b'</td><td align=center>' + music.cleanName(plist[x]).encode('utf-8') + b'</td></tr>\n')
				self.request.sendall(b'</table>')
				self.request.sendall(b'__END_OF_LIST__\n')
			elif (self.cmd == 's'):
				fff = 0;
				self.request.sendall(b'Search string: \n')
				testme = self.request.recv(1024).strip().decode('utf-8')
				dprint('Searching for: ' + testme + '\n')
				for x in range(0, len(plist)):
					if (plist[x].lower().find(testme) != -1):
						self.request.sendall(str(x).encode('utf-8') + b': ' + music.cleanName(plist[x]).encode('utf-8') + b'<br>\n')
						fff += 1
				self.request.sendall(b'__END_OF_LIST__\n')
				dprint('Found ' + str(fff) + ' items.\n')
			elif (self.cmd == 'f'):
				while True:
					try:
						self.request.sendall(b'Force song: \n')
						forceme = int(self.request.recv(1024).strip().decode('utf-8'))
						if ((forceme < 0) or (forceme >= len(plist))):
							int('fail')
						break
					except ValueError:
						self.request.sendall(b'Invalid; Try Again\n')
				tmp = 'Queued: ' + music.setForce(forceme) + '\n'	
				dprint(tmp)
				self.request.sendall(tmp.encode('utf-8'))
			elif (self.cmd == 'u'):
				tmp = 'Volume: ' + music.setVol(1) + '\n'
				dprint(tmp)
				self.request.sendall(tmp.encode('utf-8'))
			elif (self.cmd == 'd'):
				tmp = 'Volume: ' + music.setVol() + '\n'
				dprint(tmp)
				self.request.sendall(tmp.encode('utf-8'))
			elif (self.cmd == 'v'):
				while True:
					try:
						self.request.sendall(b'New volume (current=' + music.getVol().encode('utf-8') + b') [1-100] : \n')
						newvol = int(self.request.recv(1024).strip().decode('utf-8'))
						if ((newvol < 0) or (newvol > 100)):
							int('fail')
						tmp = 'Volume: ' + str(music.setVol(2, newvol)) + '\n'
						dprint(tmp)
						self.request.sendall(tmp.encode('utf-8'))
						break
					except ValueError:
						self.request.sendall(b'Error: Try Again\n')
			elif (self.cmd == 'x'):
				self.request.sendall(b'Goodbye.\n')
				dprint('Disconnecting ' + self.client_address[0] + '\n')
				self.active = 0
			elif (self.cmd == 'halt'):
				music.setDie()
				sleep(5)
				exit(0)
			else:
				self.request.sendall(b'Unknown command: ' + self.cmd.encode('utf-8') + b'\n')
	
# Do-it-to-it			
dprint('Starting TCP server...\n')
server = socketserver.TCPServer((_server_address_, _server_port_), MyTCPHandler)
print('mp3.145 is ready.\n')
server.serve_forever()
music.setDie()
